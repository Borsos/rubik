#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import conf
#from cubist.clip import Clip
from cubist.shape import Shape
from cubist.cubist import Cubist
from cubist.errors import CubistError
from cubist.argdict import InputArgDict, OutputArgDict
from cubist.variable import VariableDefinition
from cubist.filename import InputFilename, OutputFilename
from cubist.selection import Selection

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def _create_cubist(logger, args):
    cubist = Cubist(
            dtype=args.dtype,
            logger=logger,
            input_filenames=args.input_filenames,
            input_dtypes=args.input_dtypes,
            input_formats=args.input_formats,
            output_filenames=args.output_filenames,
            output_dtypes=args.output_dtypes,
            output_formats=args.output_formats,
            shapes=args.shapes,
            selections=args.selections,
            input_csv_separators=args.input_csv_separators,
            output_csv_separators=args.output_csv_separators,
            input_text_delimiters=args.input_text_delimiters,
            output_text_delimiters=args.output_text_delimiters,
            output_text_newlines=args.output_text_newlines,
            output_text_converters=args.output_text_converters,
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None),
            read_mode=getattr(args, 'read_mode', conf.DEFAULT_READ_MODE))
    return cubist

def _read(cubist, logger, args):
    expression = getattr(args, 'expression', None)
    cubist.read()
    if expression:
        cube = cubist.evaluate_expression(expression=expression)
    else:
        if args.input_filenames is None or len(args.input_filenames) == 0:
            raise CubistError("no input filenames")
        elif len(args.input_filenames) == 0:
            raise CubistError("too many input filenames")
        cube = cubist.last_cube()
    return cube

def main_write(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.in_place:
        if args.output_filenames:
            raise CubistError("--in-place/-Oi is not compatible with --output-filename/-o")
        else:
            for input_filename in args.input_filenames.values():
                args.output_filenames.add(input_filename.filename())
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    useless_run = True
    if args.print_cube:
        cubist.print_cube(cube=cube)
        useless_run = False
    if args.print_stats:
        cubist.stats(cube=cube)
        useless_run = False
    if args.output_filenames:
        useless_run = False
        cubist.write(cube=cube)
    if useless_run:
        logger.warning("warning: nothing to do; you should at least one of these options: --print/-P, --stats/-S, --output-filename/-o")
    return 0

def main():

    description = """\
Tool to read/write N-dimensional cubes

Read N-dimensional cubes, extract M-dimensional subcubes, evaluate generic numpy
expressions, and write the result.
"""
    epilog = ""
    
    argdict_input_filenames = InputArgDict(InputFilename)
    argdict_input_dtypes = InputArgDict(conf.get_dtype, default=None)
    argdict_input_formats = InputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_input_csv_separators = InputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_input_text_delimiters = InputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_shapes = InputArgDict(Shape)
    argdict_selections = InputArgDict(Selection, default=None)

    argdict_output_filenames = OutputArgDict(OutputFilename)
    argdict_output_dtypes = OutputArgDict(conf.get_dtype, default=None)
    argdict_output_formats = OutputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_output_csv_separators = OutputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_output_text_delimiters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_output_text_newlines = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_NEWLINE)
    argdict_output_text_converters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_CONVERTER)

    common_parser = argparse.ArgumentParser(
        add_help=False
    )

    common_parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    common_parser.add_argument("--trace-errors", "-E",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    parser = argparse.ArgumentParser(
        parents=[common_parser],
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.set_defaults(
        function=main_write,
    )
    
    parser.add_argument("--dtype", "-t",
        metavar="D",
        dest="dtype",
        type=conf.get_dtype,
        default=conf.DEFAULT_DATA_TYPE,
        help="data type name (--help-data-types/-hd flag to show all available data types)")

    parser.add_argument("--accept-bigger-raw-files", "-a",
        action="store_true",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    parser.add_argument("--shape", "-s",
        metavar="[D0[:D1[...]]]",
        dest="shapes",
        type=argdict_shapes.store_function(),
        default=argdict_shapes,
        help="shape of the input filename")

    parser.add_argument("--extract", "-x",
        metavar="X",
        dest="selections",
        type=argdict_selections.store_function(),
        default=argdict_selections,
        help="subcube selection")

    parser.add_argument("--expression", "-e",
        metavar="E",
        dest="expression",
        type=str,
        help="expression to evaluate; you can use the 'numpy' module (also available as 'np') and the 'cubist_numpy' module (also available as 'cnp') (--help-cubist-numpy/-hc flag to show the content of the 'cubist_numpy' module)")

    #parser.add_argument("--clip", "-c",
    #    metavar="MIN[:MAX]",
    #    dest="clip",
    #    type=Clip,
    #    help="clipping")

    input_formatting = parser.add_argument_group('input formatting')

    input_formatting.add_argument("--safe",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_SAFE,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    input_formatting.add_argument("--optimized",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_OPTIMIZED,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    input_formatting.add_argument("--input-dtype", "-It",
        metavar="D",
        dest="input_dtypes",
        type=argdict_input_dtypes.store_function(),
        default=argdict_input_dtypes,
        help="input data type name (--help-data-types/-hd flag to show all available data types)")

    input_formatting.add_argument("--input-format", "-If",
        dest="input_formats",
        type=argdict_input_formats.store_function(),
        default=argdict_input_formats,
        help="input file format")

    input_formatting.add_argument("--input-csv-separator", "-Is",
        metavar='S',
        dest="input_csv_separators",
        type=argdict_input_csv_separators.store_function(),
        default=argdict_input_csv_separators,
        help="separator to be used with '{0}' input file format".format(conf.FILE_FORMAT_CSV))

    input_formatting.add_argument("--input-text-delimiter", "-Id",
        metavar='D',
        dest="input_text_delimiters",
        type=argdict_input_text_delimiters.store_function(),
        default=argdict_input_text_delimiters,
        help="delimiter to be used with '{0}' input file format".format(conf.FILE_FORMAT_TEXT))

    output_formatting = parser.add_argument_group("output formatting")
    output_formatting.add_argument("--output-dtype", "-Ot",
        metavar="D",
        dest="output_dtypes",
        type=argdict_output_dtypes.store_function(),
        default=argdict_output_dtypes,
        help="output data type name (--help-data-types/-hd flag to show all available data types)")

    output_formatting.add_argument("--output-format", "-Of",
        dest="output_formats",
        type=argdict_output_formats.store_function(),
        default=argdict_output_formats,
        help="output file format")

    output_formatting.add_argument("--output-csv-separator", "-Os",
        metavar='S',
        dest="output_csv_separators",
        type=argdict_output_csv_separators.store_function(),
        default=argdict_output_csv_separators,
        help="separator to be used with '{0}' output file format".format(conf.FILE_FORMAT_CSV))

    output_formatting.add_argument("--output-text-delimiter", "-Od",
        metavar='D',
        dest="output_text_delimiters",
        type=argdict_output_text_delimiters.store_function(),
        default=argdict_output_text_delimiters,
        help="delimiter to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-newline", "-On",
        metavar='N',
        dest="output_text_newlines",
        type=argdict_output_text_newlines.store_function(),
        default=argdict_output_text_newlines,
        help="newline to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-converter", "-Oc",
        metavar='C',
        dest="output_text_converters",
        type=argdict_output_text_converters.store_function(),
        default=argdict_output_text_converters,
        help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(conf.FILE_FORMAT_TEXT))

    parser.add_argument("--add-var", "-V",
        metavar="N=V",
        action="append",
        type=VariableDefinition,
        default=[],
        help="add a variable definition")

    input_group = parser.add_argument_group("input options")
    input_group.add_argument("--input-filename", "-i",
        metavar='I',
        dest="input_filenames",
        type=argdict_input_filenames.store_function(),
        default=argdict_input_filenames,
        help="input filename (--help-filename/-hf flag for an explanation about filenames)")

    output_group = parser.add_argument_group("output options")

    write_output_filename_group = output_group.add_mutually_exclusive_group()
    write_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    write_output_filename_group.add_argument("--output-filename", "-o",
        metavar='O',
        dest="output_filenames",
        type=argdict_output_filenames.store_function(),
        default=argdict_output_filenames,
        help="output filename (--help-filename/-hf flag for an explanation about filenames)")

    output_group.add_argument('--print', '-P',
        dest="print_cube",
        action="store_true",
        default=False,
        help="print the result cube")

    output_group.add_argument('--stats', '-S',
        dest="print_stats",
        action="store_true",
        default=False,
        help="print statistics about the result cube")

    help_group = parser.add_argument_group("help options")
    help_group.add_argument("--help-dypes", "-ht",
        dest="help_dtypes",
        action="store_true",
        default=False,
        help="show available dtypes")

    help_group.add_argument("--help-cubist-numpy", "-hc",
        dest="help_cubist_numpy",
        action="store_true",
        default=False,
        help="show content of the cubist_numpy module")

    help_group.add_argument("--help-filename", "-hf",
        dest="help_filename",
        action="store_true",
        default=False,
        help="show available keywords for filename interpolation")

    try:
        args = parser.parse_args()
    except Exception as err:
        sys.stderr.write("error: {0}: {1}\n".format(err.__class__.__name__, err))
        sys.exit(1)

    if args.help_dtypes:
        for dtype_name, dtype_description in conf.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=dtype_name, d=dtype_description))
        sys.exit(0)

    if args.help_cubist_numpy:
        from cubist import cubist_numpy as cubist_numpy
        help(cubist_numpy)
        sys.exit(0)

    if args.help_filename:
        log.PRINT("""\
[Input filenames]
For each input filename, a variable 'i<N>' is generated referring to the cube
read from this file; 'N' is the ordinal of the input filename.

For instance, 'i0' refers to the cube read from the first file, 'i1' to the cube
read from the second file, and so on.

To be precise, that the extract expression (--extract/-x) is applied just after
the cube has been read, so 'i0' is the subcube extracted from the cube read from
the first file.

These variables referring to the read cubes can be used inside the generic
expressions (--expression/-e); for instance, "-e 'i0 - i1'" to subtract the
second cube from the first.

You can change the name of the variable referring to a cube; simply put the
variable name before the filename, separated by '=': so, the option
  -i a=a_8x10.raw
will associate the read cube to the variable 'a'.

[Output filename]
Also the output filename has a variable name (by default 'o0'); but it is never
 used.

[Filename interpolation]
Filenames are interpolated; the following keywords are substituted:
 + shape: the cube shape, for instance '3x2x4';
 + rank: the cube shape rank, for instance '3' if the shape is '3x2x4';
 + count: the number of elements, for instance '2x4';
 + dtype: the data type, for instance 'float32';
 + format: the file format ({ff})

For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
is '3x2x4' and file format is 'raw'.

This allows to specify the same filename as input and output, and still have
the output on separate files. For instance,
  -i a_{{shape}}.{{format}} -Oi -s 8x10 -If raw -Of text -Oc '%.4e'
will read 'a_8x10.raw' and write 'a_8x10.text'.
""".format(ff='|'.join(conf.FILE_FORMATS)))
        sys.exit(0)

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
