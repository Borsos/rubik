#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import conf
from cubist.shape import Shape
from cubist.units import Memory
from cubist.cubist import Cubist
from cubist.errors import CubistError, CubistMemoryError
from cubist.argdict import InputArgDict, OutputArgDict
from cubist.variable import VariableDefinition
from cubist.filename import InputFilename, OutputFilename
from cubist.extractor import Extractor

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def _create_cubist(logger, args):
    cubist = Cubist(
            dtype=args.dtype,
            logger=logger,
            input_filenames=args.input_filenames,
            input_dtypes=args.input_dtypes,
            input_formats=args.input_formats,
            output_filenames=args.output_filenames,
            output_dtypes=args.output_dtypes,
            output_formats=args.output_formats,
            shapes=args.shapes,
            extractors=args.extractors,
            input_csv_separators=args.input_csv_separators,
            output_csv_separators=args.output_csv_separators,
            input_text_delimiters=args.input_text_delimiters,
            output_text_delimiters=args.output_text_delimiters,
            output_text_newlines=args.output_text_newlines,
            output_text_converters=args.output_text_converters,
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None),
            read_mode=getattr(args, 'read_mode', conf.DEFAULT_READ_MODE),
            optimized_min_size=args.optimized_min_size,
            memory_limit=args.memory_limit,
            split_dimensions=args.split_dimensions,
            clobber=args.clobber,
            print_cube=args.print_cube,
            print_stats=args.print_stats)
    return cubist

def _read(cubist, logger, args):
    expression = getattr(args, 'expression', None)
    cubist.read()
    if expression:
        cube = cubist.evaluate_expression(expression=expression)
    else:
        if args.input_filenames is None or len(args.input_filenames) == 0:
            logger.warning("warning: nothing to do; you should use at least one option between '--input-filename/-i', '--expression/-e'")
        elif len(args.input_filenames) == 0:
            logger.warning("warning: loading more than an input file is useless if '--expression/-e' is not used")
        cube = cubist.last_cube()
    return cube

def main_write(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.in_place:
        if args.output_filenames:
            raise CubistError("--in-place/-Oi is not compatible with --output-filename/-o")
        else:
            for input_filename in args.input_filenames.values():
                args.output_filenames.add(input_filename.filename())
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    cubist.output(cube=cube)
    return 0

def main():

    description = """\
Tool to read/write N-dimensional cubes

Read N-dimensional cubes, extract M-dimensional subcubes, evaluate generic numpy
expressions, and write the result.
"""
    epilog = ""
    
    argdict_input_filenames = InputArgDict(InputFilename)
    argdict_input_dtypes = InputArgDict(conf.get_dtype, default=None)
    argdict_input_formats = InputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_input_csv_separators = InputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_input_text_delimiters = InputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_shapes = InputArgDict(Shape)
    argdict_extractors = InputArgDict(Extractor, default=None)

    argdict_output_filenames = OutputArgDict(OutputFilename)
    argdict_output_dtypes = OutputArgDict(conf.get_dtype, default=None)
    argdict_output_formats = OutputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_output_csv_separators = OutputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_output_text_delimiters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_output_text_newlines = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_NEWLINE)
    argdict_output_text_converters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_CONVERTER)

    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.set_defaults(
        function=main_write,
    )
    
    global_group = parser.add_argument_group(
        "global options",
        description="""\
Global options""")

    global_group.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    global_group.add_argument('--version',
        action='version',
        version='%(prog)s {version}'.format(version=conf.VERSION))

    global_group.add_argument("--trace-errors", "-E",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    global_group.add_argument("--safe",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_SAFE,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    global_group.add_argument("--optimized",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_OPTIMIZED,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    global_group.add_argument("--optimized-min-size",
        metavar="S",
        dest="optimized_min_size",
        type=Memory,
        default=conf.DEFAULT_OPTIMIZED_MIN_SIZE,
        help="switch from optimized to safe read mode when reading less than C bytes (a huge value is equivalent to --safe)")

    global_group.add_argument("--memory-limit", "-m",
        metavar="L[units]",
        dest="memory_limit",
        type=Memory,
        default=conf.DEFAULT_LIMIT_MEMORY,
        help="when more than the given limit is needed for a single extracted cube, raise an error")

    global_group.add_argument("--dtype", "-t",
        metavar="D",
        dest="dtype",
        type=conf.get_dtype,
        default=conf.DEFAULT_DATA_TYPE,
        help="data type name (--help-data-types/-hd to show all available data types)")

    global_group.add_argument("--accept-bigger-raw-files", "-a",
        action="store_false",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    global_group.add_argument("--clobber",
        action="store_true",
        default=conf.DEFAULT_CLOBBER,
        help="overwrite existing output files")

    global_group.add_argument("--no-clobber",
        action="store_false",
        default=conf.DEFAULT_CLOBBER,
        help="do not overwrite existing output files")

    global_group.add_argument("--expression", "-e",
        metavar="E",
        dest="expression",
        type=str,
        help="expression to evaluate (--help-expression/-he for more information)")

    global_group.add_argument("--add-var", "-V",
        metavar="N=V",
        action="append",
        type=VariableDefinition,
        default=[],
        help="add a variable definition (--help-user-defined-variables/-hV for more information)")

    global_group.add_argument("--random-seed", "-r",
        type=int,
        default=None,
        help="set the random seed")

    input_group = parser.add_argument_group(
        "input options",
        description="""\
Options related to input files. All these options can be labeled;
see --help-labeled-options for more information.""")

    input_group.add_argument("--input-filename", "-i",
        metavar='I',
        dest="input_filenames",
        type=argdict_input_filenames.store_function(),
        default=argdict_input_filenames,
        help="input filename (--help-filename/-hf for an explanation about filenames)")

    input_group.add_argument("--shape", "-s",
        metavar="[D0[:D1[...]]]",
        dest="shapes",
        type=argdict_shapes.store_function(),
        default=argdict_shapes,
        help="shape of the input filename")

    input_group.add_argument("--extract", "-x",
        metavar="X",
        dest="extractors",
        type=argdict_extractors.store_function(),
        default=argdict_extractors,
        help="subcube extractor (--help-extractor/-he for more information)")

    input_group.add_argument("--input-dtype", "-It",
        metavar="D",
        dest="input_dtypes",
        type=argdict_input_dtypes.store_function(),
        default=argdict_input_dtypes,
        help="input data type name (--help-data-types/-hd to show all available data types)")

    input_group.add_argument("--input-format", "-If",
        dest="input_formats",
        type=argdict_input_formats.store_function(),
        default=argdict_input_formats,
        help="input file format")

    input_group.add_argument("--input-csv-separator", "-Is",
        metavar='S',
        dest="input_csv_separators",
        type=argdict_input_csv_separators.store_function(),
        default=argdict_input_csv_separators,
        help="separator to be used with '{0}' input file format".format(conf.FILE_FORMAT_CSV))

    input_group.add_argument("--input-text-delimiter", "-Id",
        metavar='D',
        dest="input_text_delimiters",
        type=argdict_input_text_delimiters.store_function(),
        default=argdict_input_text_delimiters,
        help="delimiter to be used with '{0}' input file format".format(conf.FILE_FORMAT_TEXT))

    output_group = parser.add_argument_group(
        "output options",
        description="""\
Options related to output files. All these options can be labeled;
see --help-labeled-options for more information.""")

    write_output_filename_group = output_group.add_mutually_exclusive_group()
    write_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    write_output_filename_group.add_argument("--output-filename", "-o",
        metavar='O',
        dest="output_filenames",
        type=argdict_output_filenames.store_function(),
        default=argdict_output_filenames,
        help="output filename (--help-filename/-hf for an explanation about filenames)")

    output_group.add_argument('--print', '-P',
        dest="print_cube",
        action="store_true",
        default=False,
        help="print the result cube")

    output_group.add_argument('--stats', '-S',
        dest="print_stats",
        action="store_true",
        default=False,
        help="print statistics about the result cube")

    output_group.add_argument("--split", "-l",
        metavar="D",
        dest="split_dimensions",
        type=int,
        action="append",
        default=[],
        help="split dimension D (--help-split/-hl for more information)")

    output_group.add_argument("--output-dtype", "-Ot",
        metavar="D",
        dest="output_dtypes",
        type=argdict_output_dtypes.store_function(),
        default=argdict_output_dtypes,
        help="output data type name (--help-data-types/-hd to show all available data types)")

    output_group.add_argument("--output-format", "-Of",
        dest="output_formats",
        type=argdict_output_formats.store_function(),
        default=argdict_output_formats,
        help="output file format")

    output_group.add_argument("--output-csv-separator", "-Os",
        metavar='S',
        dest="output_csv_separators",
        type=argdict_output_csv_separators.store_function(),
        default=argdict_output_csv_separators,
        help="separator to be used with '{0}' output file format".format(conf.FILE_FORMAT_CSV))

    output_group.add_argument("--output-text-delimiter", "-Od",
        metavar='D',
        dest="output_text_delimiters",
        type=argdict_output_text_delimiters.store_function(),
        default=argdict_output_text_delimiters,
        help="delimiter to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_group.add_argument("--output-text-newline", "-On",
        metavar='N',
        dest="output_text_newlines",
        type=argdict_output_text_newlines.store_function(),
        default=argdict_output_text_newlines,
        help="newline to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_group.add_argument("--output-text-converter", "-Oc",
        metavar='C',
        dest="output_text_converters",
        type=argdict_output_text_converters.store_function(),
        default=argdict_output_text_converters,
        help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(conf.FILE_FORMAT_TEXT))



    help_group = parser.add_argument_group(
        "help options",
        description="""\
Options to show help on specific topics """)

    help_group.add_argument("--help-dtypes", "-ht",
        dest="help_dtypes",
        action="store_true",
        default=False,
        help="show available dtypes")

    help_group.add_argument("--help-labeled-options", "-ho",
        dest="help_labeled_options",
        action="store_true",
        default=False,
        help="show help about labeled options")

    help_group.add_argument("--help-expression", "-he",
        dest="help_expression",
        action="store_true",
        default=False,
        help="show help about generic numpy expressions")

    help_group.add_argument("--help-extractor", "-hx",
        dest="help_extractor",
        action="store_true",
        default=False,
        help="show help about extractors")

    help_group.add_argument("--help-user-defined-variables", "-hV",
        dest="help_user_defined_variables",
        action="store_true",
        default=False,
        help="show help about user defined variables")

    help_group.add_argument("--help-numpy", "-hn",
        dest="help_numpy",
        action="store_true",
        default=False,
        help="show content of the numpy module")

    help_group.add_argument("--help-cubist-numpy", "-hc",
        dest="help_cubist_numpy",
        action="store_true",
        default=False,
        help="show content of the cubist_numpy module")

    help_group.add_argument("--help-filenames", "-hf",
        dest="help_filenames",
        action="store_true",
        default=False,
        help="show available keywords for filename interpolation")

    help_group.add_argument("--help-split", "-hl",
        dest="help_split",
        action="store_true",
        default=False,
        help="help about splitting dimensions")

    help_group.add_argument("--help-environment-variables", "-hE",
        dest="help_environment_variables",
        action="store_true",
        default=False,
        help="help about environment variables")

    help_group.add_argument("--help-creating-cubes", "-hC",
        dest="help_creating_cubes",
        action="store_true",
        default=False,
        help="how to create cubes from scratch")

    help_group.add_argument("--help-output", "-hO",
        dest="help_output",
        action="store_true",
        default=False,
        help="help about output")

    help_group.add_argument("--help-memory-usage", "-hM",
        dest="help_memory_usage",
        action="store_true",
        default=False,
        help="help about memory usage")

    args = conf.CUBIST_OPTIONS + sys.argv[1:]
    try:
        args = parser.parse_args(args)
    except Exception as err:
        sys.stderr.write("error: {0}: {1}\n".format(err.__class__.__name__, err))
        sys.exit(1)

    if args.help_labeled_options:
        log.PRINT("""\
Labeled options
===============
--------------------------------------------------------------------------------
Labeled options are options whose value can be preceded by a label assignment.

There are two kind of labeled options:
* input labeled options, referring to input files, and
* output labeled options, referring to output files.

For instance, '--shape/-s' is an input labeled option. It can be used:
* unlabeled: '--shape 8x10'
* labeled: '--shape i0=8x10'

When used unlabeled, the shape will apply to all the input filenames that do not
have a labeled shape option.
On the other hand, when used labeled, it applies only to the input filename that
has the same label.
If multiple unlabeled --shape/-s options are passed, they are applied to the
corresponding input files: the first unlabeled option to the first input file,
the second unlabeled option to the second file, and so on.

For instance:

* 'cubist -i a.raw -i b.raw -c i.raw -s 8x10 ...': the shape 8x10 is assigned to
  all the input files.
* 'cubist -i a.raw -i b.raw -c i.raw -s 8x10 -s i1=8x20x10 ...': the shape 8x10
  is assigned to 'a.raw' and 'c.raw', since 'b.raw' has a labeled shape option, so
  its shape is 8x20x10;
* 'cubist -i a.raw -i b.raw -c i.raw -s 8x10 -s 8x20x10 ...': in this case,
  - 'a.raw' has shape 8x10;
  - 'b.raw' and 'c.raw' have shape 8x20x10.

The same applies to output labeled options.
""")
        sys.exit(0)

    if args.help_dtypes:
        log.PRINT("""\
Available dtypes
================
This is the list of the available numpy dtypes:
""")
        for dtype_name, dtype_description in conf.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=dtype_name, d=dtype_description))
        sys.exit(0)

    if args.help_cubist_numpy:
        from cubist import cubist_numpy as cubist_numpy
        help(cubist_numpy)
        sys.exit(0)

    if args.help_numpy:
        help(np)
        sys.exit(0)

    if args.help_expression:
        log.PRINT("""\
Generic numpy expressions
=========================
The --expression/-e options allows to pass a generic numpy expression to be
evaluated. The input cubes are available through the labels referring to them.

From the expression you can access:
* the numpy module, as 'numpy' or 'np';
* the cubist_numpy module, as 'cubist_numpy' or 'cnp';
* all the used defined variables.

The cubist_numpy module provides some numpy-based functions to operate with
cubes; see --help-cubist-numpy.
""")
        sys.exit(0)

    if args.help_extractor:
        log.PRINT("""\
Extractors
==========
An extractor can be associated to each input file to read only a portion of that
file. Due to memory opimization, only the portion is read, so there is no need
to temporarily store the entire file. This means that if you want to read only a
subcube from a huge file, you will use memory only for the subcube.

Extractors are lists of index selectors separated by 'x' or ','.

Each input file can have a specific extractor. The shape and the extractor must
have the same rank.

Each index selector can be:
* a python slice [start:]stop[:step], for instance
  - ':' -> select all indices
  - '1:' -> select all indices but the first
  - ':-3' -> select all indices but the last three
  - '::2' -> select from the first to the last indices with stride 2
* an integer number; in this case, only the corresponding index is selected on
  that dimension, and the dimension is skipped in the output.

For instance, if the shape is '8x1000x30':
* '-x :x0x:' will extract the subcube '8x30' corresponding to the plane with 0
  on the second dimension
* '-x 3:x8:10x:5' will extract a subcube '5x2x5' (remember that, in a python
  slice, the start is always included and the stop is always excluded.
""")
        sys.exit(0)

    if args.help_user_defined_variables:
        log.PRINT("""\
User defined variables
======================
User defined variables can be used in generic numpy expressions. For instance:
  -V alpha=1.5 -V beta=-0.5 -e 'alpha * i0 + beta * i1'
is equivalent to 
  -e '1.5 * i0 - 0.5 * i1'
Also input cubes and previusly defined variables can be used:
  -V a=10 -V b='a + 5' -V c='i0 * b'
will set
  * a = 10
  * b = 15
  * c = i0 * 15 ('i0' is the first cube)
""")
        sys.exit(0)

    if args.help_split:
        log.PRINT("""\
Splitting dimensions
====================
Suppose you have a _8x4x10_ cube, and you want to write _4_ _8x10_ cubes, one
for each index in the second dimension. The command is:

$ cubist -i a_{shape}.{format} -s 8x4x10 --split 1 -o s_{shape}.{d1}.{format} -v
reading 320 'float32' elements (1280 bytes) from 'raw' file 'a_8x4x10.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.0.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.1.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.2.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.3.raw'...
$

During the output phase, a loop over the four values for the second index is
done; the 3-D cube is sliced across the second dimension, and each plane
is saved into a different file.

The 'd1' key has been added to the available keys for the output filename
interpolation.

""")
        sys.exit(0)

    if args.help_filenames:
        log.PRINT("""\
Input filenames
===============
For each input filename, a label 'i<N>' is generated referring to the cube
read from this file; 'N' is the ordinal of the input filename.

For instance, 'i0' refers to the cube read from the first file, 'i1' to the cube
read from the second file, and so on.

These labels can be used to
* set specific parameters for each input file, like:
  - the format
  - the dtype
  - the shape
  - an extractor
  for instance, '-s i0=8x10' sets the shape for the first input cube only;
* refer to the corresponding cube in a generic numpy expression; in this case,
  'i0' refers to the cube read from the first input filename, after the
  extractor has been applied (indeed extractors are applied just during the
  file loading).

See --help-labeled-options/-ho for more information about options referring to
labeled files.

You can change the name of the label referring to a cube; simply put the
label before the filename, separated by '=': so, the option '-i a=a_8x10.raw'
will associate the read cube to the label 'a'; then, '-x a=:2x2:' sets an 
extractor for the file 'a_8x10.raw' only, and '-e "2.5 * a"' multiplies
the cube extracted from 'a_8x10.raw' by 2.5.

Output filenames
================
Also the output filenames have a label (by default 'o0'); the label can be used
to set specific parameters on the output file, for instance the format. It
cannot be used in the generic numpy expression.

For instance, '-o x=x_8x10.raw --output-dtype x=float64' applies the dtype
'float64' to the output file 'x_8x10.raw'.

Filename interpolation
======================
Filenames are interpolated; the following keywords are substituted:
* shape: the cube shape, for instance '3x2x4';
* rank: the cube shape rank, for instance '3' if the shape is '3x2x4';
* count: the number of elements, for instance '2x4';
* dtype: the data type, for instance 'float32';
* format: the file format ({ff})

For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
is '3x2x4' and file format is 'raw'.

This allows to specify the same filename as input and output, and still have
the output on separate files. For instance,
  -i a_{{shape}}.{{format}} -Oi -s 8x10 -If raw -Of text -Oc '%.4e'
will read 'a_8x10.raw' and write 'a_8x10.text'.

File formats
============
Three file formats are available:
* 'raw' is the default, for binary files; they are not portable across different
  platforms;
* 'text' is for text files; they have sub-options:
  - delimiter (usually a space) separating values in a row;
  - newline (usually '\\n') separating rows;
  - converter (for instance '%.18e') is the format specifier for values.
  for input files only the 'delimiter' can be set;
* 'csv' is for text files consisting of values separated by a separator; you can
  set
  - separator (by default ',') the separator between values.
""".format(ff='|'.join(conf.FILE_FORMATS)))
        sys.exit(0)

    if args.help_environment_variables:
        log.PRINT("""\
Environment variables
=====================
Currently the only accepted environment variable is '$CUBIST_OPTIONS', that can
be set to a list of valid cubist options. For instance:

$ export CUBIST_OPTIONS='-v --memory-limit 16gb'

These options will be prepended to the list of command line arguments. So, they
can be overwritten by command line arguments.
""")
        sys.exit(0)

    if args.help_creating_cubes:
        log.PRINT("""\
Creating cubes from scratch
===========================
It is possible to create cubes from scratch. Indeed, it is possible to use a
generic numpy expression without input filenames.

For instance:

$ cubist -e 'np.linspace(0, 79, 80).reshape((8, 10))' -o lc_{shape}.{format}

will create a cube with values from 0.0 to 79.0 with increment 1.0.

The cubist_numpy (or cnp) module has some convenience functions to easily
create cubes:

$ cubist -e 'cnp.linear_cube("8x10")' -o lc_{shape}.{format}

creates the same cube;

$ cubist -e 'cnp.random_cube("8x10")' -o rc_{shape}.{format}

creates a random cube; and

$ cubist -e 'cnp.fill_cube("8x10", 8.0)' -o cc_{shape}.{format}

creates a const cube with all values 8.0.

See --help-cubist-numpy to see the content of the cubist_numpy module.
""")
        sys.exit(0)

    if args.help_output:
        log.PRINT("""\
Output modes
============
--------------------------------------------------------------------------------
There are three output modes:
* writing the result to a file (--output-filename/-o); you can specify the file
  format, dtype, etc...
* print the result to a file (--print/-P)
* print statistics about the resulting cube to a file (--stats/-S)
""")
        sys.exit(0)

    if args.help_memory_usage:
        log.PRINT("""\
Memory usage
============
A complete control of the memory usage is not possible, due to the possibility
to execute generic numpy expressions. Nevertheless cubist can check the amount
of memory necessary to read input files and store the result. You can provide
a limit for this amout of memory using the '--memory-limit/m' option.

For instance, with the option '--memory-limit 16gb', you will not allowed to
read more than 16 gb of data. The default memory limit is '0', which means no
limit.

Optimized read vs Safe read
===========================
When loading input files, two algorithms are available:
* optimized read
* safe read
The optimized read is memory efficient: if an extractor is used, it is applied
directly during the read, so only the exact amount of memory to store the
subcube is used. On the other hand, the safe read reads the full cube, and
then applies the extractor in memory.

The two algorithms are fully equivalent, but the safe one can do some more
checks (for instance, if the file format is 'text' or 'csv', the optimized
algorithm is not able to check if the input file is bigger than the specified
shape).

The safe algorithm is used when the extractor is missing, or when the
extracted subcube has the same size as the input cube. Moreover, the safe
algorithm is used if the size of the input cube is lower than a limit that
can be set through the '--optimized-min-size' option. For instance, if
'--optimized-min-size 1gb', the safe algorithm is always used if the input
file is less than 1gb. By default, the optimized min size is 100mb.
""")
        sys.exit(0)

    logger = log.set_logger(args.verbose_level)
    
    if args.random_seed is not None:
        np.random.seed(args.random_seed)
        random.seed(args.random_seed)

    return_code = 0
    try:
        return_code = args.function(logger, args)
    except CubistMemoryError:
        log.trace_error(args.trace_errors)
        logger.error("error: the memory limit of {0} has been exceeded; you can try to increase the memory limit (--memory-limit/-m)".format(args.memory_limit))
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
