#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import data_types
#from cubist.clip import Clip
from cubist.shape import Shape
from cubist.cubist import Cubist
from cubist.errors import CubistError
from cubist.variable import VariableDefinition
from cubist.filename import InputFilename, OutputFilename
from cubist.selection import Selection

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def _create_cubist(logger, args):
    #logger.debug("# origins are  {0}".format(origins))
    #logger.debug("# shape is     {0}".format(shape))
    #logger.debug("# selection is {0}".format(selection))
    #logger.debug("# data_type is {0}".format(args.data_type))
    cubist = Cubist(
            data_type=args.data_type,
            logger=logger,
            input_csv_separator=getattr(args, 'input_csv_separator', None),
            output_csv_separator=getattr(args, 'output_csv_separator', None),
            input_text_delimiter=getattr(args, 'input_text_delimiter', None),
            output_text_delimiter=getattr(args, 'output_text_delimiter', None),
            input_text_newline=getattr(args, 'input_text_newline', None),
            output_text_newline=getattr(args, 'output_text_newline', None),
            input_text_converter=getattr(args, 'input_text_converter', None),
            output_text_converter=getattr(args, 'output_text_converter', None),
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None))
    return cubist

def _read_and_extract(cubist, logger, args, input_filename, selection):
    if args.shape is None:
        raise CubistError("--shape/-s is mandatory when input files are provided")
    cube = cubist.read(
            shape=args.shape,
            input_format=args.input_format,
            input_filename=input_filename,
            selection=selection)
    return cube

def _read(cubist, logger, args):
    selection = getattr(args, 'selection', None)
    expression = getattr(args, 'expression', None)
    if expression:
        for input_filename in args.input_filenames:
            _read_and_extract(cubist, logger, args, input_filename, selection)
        cube = cubist.evaluate_expression(expression=expression)
    else:
        if len(args.input_filenames) > 1:
            raise CubistError("too many input filenames")
        elif len(args.input_filenames) == 0:
            raise CubistError("no input filenames")
        input_filename = args.input_filenames[0]
        cube = _read_and_extract(cubist, logger, args, input_filename, selection)
    #clip_arg = getattr(args, 'clip', None)
    #if clip_arg is not None:
    #    cube = cubist.clip(cube=cube, clip=clip_arg)
    return cube

def main_print(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.print_cube(cube=cube)
    return 0

def main_stat(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.stat(cube=cube)
    return 0

def main_create(logger, args):
    cubist = _create_cubist(logger, args)
    cube = cubist.create(shape=args.shape, creation_mode=args.creation_mode)
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=args.output_filename)
    return 0
    
def main_write(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.in_place:
        if args.output_filename is None:
            if len(args.input_filenames) == 1:
                output_filename = OutputFilename(args.input_filenames[0])
            else:
                raise CubistError("--in-place/-Oi requires a single --input-filename option")
        else:
            raise CubistError("--in-place/-Oi is not compatible with --output-filename/-o")
    else:
        output_filename = args.output_filename
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    useless_run = True
    if args.print_cube:
        cubist.print_cube(cube=cube)
        useless_run = False
    if args.print_stats:
        cubist.stats(cube=cube)
        useless_run = False
    if output_filename is not None:
        useless_run = False
        cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=output_filename)
    if useless_run:
        logger.warning("warning: nothing to do; you should at least one of these options: --print/-P, --stats/-S, --output-filename/-o")
    return 0

def main():

    description = """\
Tool to read/write N-dimensional cubes

Read N-dimensional cubes, extract M-dimensional subcubes, evaluate generic numpy
expressions, and write the result.
"""
    epilog = ""
    
    common_parser = argparse.ArgumentParser(
        add_help=False
    )

    common_parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    common_parser.add_argument("--trace-errors", "-t",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    parser = argparse.ArgumentParser(
        parents=[common_parser],
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.set_defaults(
        function=main_write,
    )
    
    parser.add_argument("--data-type", "--dtype", "-d",
        metavar="D",
        dest="data_type",
        choices=data_types.DATA_TYPES.keys(),
        default=data_types.DEFAULT_DATA_TYPE,
        help="data type name (add --help-data-types/-hd flag to show all available data types)")

    parser.add_argument("--accept-bigger-raw-files", "-a",
        action="store_true",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    parser.add_argument("--shape", "-s",
        metavar="[D0[:D1[...]]]",
        type=Shape,
        required=False,
        help="shape of the input filename")

    parser.add_argument("--extract", "-x",
        metavar="X",
        dest="selection",
        type=Selection,
        required=False,
        help="subcube selection")

    parser.add_argument("--expression", "-e",
        metavar="E",
        dest="expression",
        type=str,
        required=False,
        help="expression to evaluate; you can use the 'numpy' module (also available as 'np') and the 'cubist_numpy' module (also available as 'cnp') (add --help-cubist-numpy/-hc flag to show the content of the 'cubist_numpy' module)")

    #parser.add_argument("--clip", "-c",
    #    metavar="MIN[:MAX]",
    #    dest="clip",
    #    type=Clip,
    #    help="clipping")

    input_formatting = parser.add_argument_group('input formatting')
    input_formatting.add_argument("--input-format", "-If",
        dest="input_format",
        choices=Cubist.FILE_FORMATS,
        default=Cubist.DEFAULT_FILE_FORMAT,
        help="input file format")

    input_formatting.add_argument("--input-csv-separator", "-Is",
        metavar='S',
        dest="input_csv_separator",
        default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
        help="separator to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_CSV))

    input_formatting.add_argument("--input-text-delimiter", "-Id",
        metavar='D',
        dest="input_text_delimiter",
        default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
        help="delimiter to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))

    input_formatting.add_argument("--input-text-newline", "-In",
        metavar='N',
        dest="input_text_newline",
        default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
        help="newline to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))

    input_formatting.add_argument("--input-text-converter", "-Ic",
        metavar='C',
        dest="input_text_converter",
        default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
        help="converter to be used with '{0}' input file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

    output_formatting = parser.add_argument_group("output formatting")
    output_formatting.add_argument("--output-format", "-Of",
        dest="output_format",
        choices=Cubist.FILE_FORMATS,
        default=Cubist.DEFAULT_FILE_FORMAT,
        help="output file format")

    output_formatting.add_argument("--output-csv-separator", "-Os",
        metavar='S',
        dest="output_csv_separator",
        default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
        help="separator to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_CSV))

    output_formatting.add_argument("--output-text-delimiter", "-Od",
        metavar='D',
        dest="output_text_delimiter",
        default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
        help="delimiter to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-newline", "-On",
        metavar='N',
        dest="output_text_newline",
        default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
        help="newline to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-converter", "-Oc",
        metavar='C',
        dest="output_text_converter",
        default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
        help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

    parser.add_argument("--add-var", "-V",
        metavar="N=V",
        action="append",
        type=VariableDefinition,
        default=[],
        help="add a variable definition")

    input_group = parser.add_argument_group("input options")
    input_group.add_argument("--input-filename", "-i",
        metavar='I',
        dest="input_filenames",
        type=InputFilename,
        action="append",
        default=[],
        help="input filename (add --help-filename/-hf flag for an explanation about filenames)")

    output_group = parser.add_argument_group("output options")

    write_output_filename_group = output_group.add_mutually_exclusive_group()
    write_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    write_output_filename_group.add_argument("--output-filename", "-o",
        metavar='O',
        dest="output_filename",
        type=OutputFilename,
        required=False,
        help="output filename (add --help-filename/-hf flag for an explanation about filenames)")

    output_group.add_argument('--print', '-P',
        dest="print_cube",
        action="store_true",
        default=False,
        help="print the result cube")

    output_group.add_argument('--stats', '-S',
        dest="print_stats",
        action="store_true",
        default=False,
        help="print statistics about the result cube")

    help_group = parser.add_argument_group("help options")
    help_group.add_argument("--help-data-types", "-hd",
        dest="help_data_types",
        action="store_true",
        default=False,
        help="show available data types")

    help_group.add_argument("--help-cubist-numpy", "-hc",
        dest="help_cubist_numpy",
        action="store_true",
        default=False,
        help="show content of the cubist_numpy module")

    help_group.add_argument("--help-filename", "-hf",
        dest="help_filename",
        action="store_true",
        default=False,
        help="show available keywords for filename interpolation")

    args = parser.parse_args()

    if args.help_data_types:
        for data_type_name, data_type_description in data_types.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=data_type_name, d=data_type_description))
        sys.exit(0)

    if args.help_cubist_numpy:
        from cubist import cubist_numpy as cubist_numpy
        help(cubist_numpy)
        sys.exit(0)

    if args.help_filename:
        log.PRINT("""\
[Input filenames]
For each input filename, a variable 'i<N>' is generated referring to the cube
read from this file; 'N' is the ordinal of the input filename.

For instance, 'i0' refers to the cube read from the first file, 'i1' to the cube
read from the second file, and so on.

To be precise, that the extract expression (--extract/-x) is applied just after
the cube has been read, so 'i0' is the subcube extracted from the cube read from
the first file.

These variables referring to the read cubes can be used inside the generic
expressions (--expression/-e); for instance, "-e 'i0 - i1'" to subtract the
second cube from the first.

You can change the name of the variable referring to a cube; simply put the
variable name before the filename, separated by '=': so, the option
  -i a=a_8x10.raw
will associate the read cube to the variable 'a'.

[Output filename]
Also the output filename has a variable name (by default 'o0'); but it is never
 used.

[Filename interpolation]
Filenames are interpolated; the following keywords are substituted:
 + shape: the cube shape, for instance '3x2x4';
 + rank: the cube shape rank, for instance '3' if the shape is '3x2x4';
 + count: the number of elements, for instance '2x4';
 + data_type: the data type, for instance 'float32';
 + format: the file format ({ff})

For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
is '3x2x4' and file format is 'raw'.

This allows to specify the same filename as input and output, and still have
the output on separate files. For instance,
  -i a_{{shape}}.{{format}} -Oi -s 8x10 -If raw -Of text -Oc '%.4e'
will read 'a_8x10.raw' and write 'a_8x10.text'.
""".format(ff='|'.join(Cubist.FILE_FORMATS)))
        sys.exit(0)

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
