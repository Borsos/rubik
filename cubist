#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import conf
from cubist.shape import Shape
from cubist.cubist import Cubist
from cubist.errors import CubistError
from cubist.argdict import InputArgDict, OutputArgDict
from cubist.variable import VariableDefinition
from cubist.filename import InputFilename, OutputFilename
from cubist.extractor import Extractor

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def _create_cubist(logger, args):
    cubist = Cubist(
            dtype=args.dtype,
            logger=logger,
            input_filenames=args.input_filenames,
            input_dtypes=args.input_dtypes,
            input_formats=args.input_formats,
            output_filenames=args.output_filenames,
            output_dtypes=args.output_dtypes,
            output_formats=args.output_formats,
            shapes=args.shapes,
            extractors=args.extractors,
            input_csv_separators=args.input_csv_separators,
            output_csv_separators=args.output_csv_separators,
            input_text_delimiters=args.input_text_delimiters,
            output_text_delimiters=args.output_text_delimiters,
            output_text_newlines=args.output_text_newlines,
            output_text_converters=args.output_text_converters,
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None),
            read_mode=getattr(args, 'read_mode', conf.DEFAULT_READ_MODE),
            loop_dimensions=args.loop_dimensions,
            clobber=args.clobber,
            print_cube=args.print_cube,
            print_stats=args.print_stats)
    return cubist

def _read(cubist, logger, args):
    expression = getattr(args, 'expression', None)
    cubist.read()
    if expression:
        cube = cubist.evaluate_expression(expression=expression)
    else:
        if args.input_filenames is None or len(args.input_filenames) == 0:
            raise CubistError("no input filenames")
        elif len(args.input_filenames) == 0:
            raise CubistError("too many input filenames")
        cube = cubist.last_cube()
    return cube

def main_write(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.in_place:
        if args.output_filenames:
            raise CubistError("--in-place/-Oi is not compatible with --output-filename/-o")
        else:
            for input_filename in args.input_filenames.values():
                args.output_filenames.add(input_filename.filename())
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    cubist.output(cube=cube)
    return 0

def main():

    description = """\
Tool to read/write N-dimensional cubes

Read N-dimensional cubes, extract M-dimensional subcubes, evaluate generic numpy
expressions, and write the result.
"""
    epilog = ""
    
    argdict_input_filenames = InputArgDict(InputFilename)
    argdict_input_dtypes = InputArgDict(conf.get_dtype, default=None)
    argdict_input_formats = InputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_input_csv_separators = InputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_input_text_delimiters = InputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_shapes = InputArgDict(Shape)
    argdict_extractors = InputArgDict(Extractor, default=None)

    argdict_output_filenames = OutputArgDict(OutputFilename)
    argdict_output_dtypes = OutputArgDict(conf.get_dtype, default=None)
    argdict_output_formats = OutputArgDict(str, default=conf.DEFAULT_FILE_FORMAT)
    argdict_output_csv_separators = OutputArgDict(str, default=conf.FILE_FORMAT_CSV_SEPARATOR)
    argdict_output_text_delimiters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_DELIMITER)
    argdict_output_text_newlines = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_NEWLINE)
    argdict_output_text_converters = OutputArgDict(str, default=conf.FILE_FORMAT_TEXT_CONVERTER)

    parser = argparse.ArgumentParser(
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.set_defaults(
        function=main_write,
    )
    
    global_group = parser.add_argument_group("global options")

    global_group.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    global_group.add_argument('--version',
        action='version',
        version='%(prog)s {version}'.format(version=conf.VERSION))

    global_group.add_argument("--trace-errors", "-E",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    global_group.add_argument("--safe",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_SAFE,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    global_group.add_argument("--optimized",
        dest="read_mode",
        action="store_const",
        const=conf.READ_MODE_OPTIMIZED,
        default=conf.DEFAULT_READ_MODE,
        help="safe read mode")

    global_group.add_argument("--dtype", "-t",
        metavar="D",
        dest="dtype",
        type=conf.get_dtype,
        default=conf.DEFAULT_DATA_TYPE,
        help="data type name (--help-data-types/-hd flag to show all available data types)")

    global_group.add_argument("--accept-bigger-raw-files", "-a",
        action="store_false",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    global_group.add_argument("--clobber",
        action="store_true",
        default=conf.DEFAULT_CLOBBER,
        help="overwrite existing output files")

    global_group.add_argument("--no-clobber",
        action="store_false",
        default=conf.DEFAULT_CLOBBER,
        help="do not overwrite existing output files")

    global_group.add_argument("--expression", "-e",
        metavar="E",
        dest="expression",
        type=str,
        help="expression to evaluate (--help-expression/-he for more information)")

    global_group.add_argument("--add-var", "-V",
        metavar="N=V",
        action="append",
        type=VariableDefinition,
        default=[],
        help="add a variable definition (--help-user-defined-variables/-hV for more information)")

    input_group = parser.add_argument_group("input options")

    input_group.add_argument("--input-filename", "-i",
        metavar='I',
        dest="input_filenames",
        type=argdict_input_filenames.store_function(),
        default=argdict_input_filenames,
        help="input filename (--help-filename/-hf flag for an explanation about filenames)")

    input_group.add_argument("--shape", "-s",
        metavar="[D0[:D1[...]]]",
        dest="shapes",
        type=argdict_shapes.store_function(),
        default=argdict_shapes,
        help="shape of the input filename")

    input_group.add_argument("--extract", "-x",
        metavar="X",
        dest="extractors",
        type=argdict_extractors.store_function(),
        default=argdict_extractors,
        help="subcube extractor (--help-extractor/-he for more information)")

    input_group.add_argument("--input-dtype", "-It",
        metavar="D",
        dest="input_dtypes",
        type=argdict_input_dtypes.store_function(),
        default=argdict_input_dtypes,
        help="input data type name (--help-data-types/-hd flag to show all available data types)")

    input_group.add_argument("--input-format", "-If",
        dest="input_formats",
        type=argdict_input_formats.store_function(),
        default=argdict_input_formats,
        help="input file format")

    input_group.add_argument("--input-csv-separator", "-Is",
        metavar='S',
        dest="input_csv_separators",
        type=argdict_input_csv_separators.store_function(),
        default=argdict_input_csv_separators,
        help="separator to be used with '{0}' input file format".format(conf.FILE_FORMAT_CSV))

    input_group.add_argument("--input-text-delimiter", "-Id",
        metavar='D',
        dest="input_text_delimiters",
        type=argdict_input_text_delimiters.store_function(),
        default=argdict_input_text_delimiters,
        help="delimiter to be used with '{0}' input file format".format(conf.FILE_FORMAT_TEXT))

    output_group = parser.add_argument_group("output options")
    write_output_filename_group = output_group.add_mutually_exclusive_group()
    write_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    write_output_filename_group.add_argument("--output-filename", "-o",
        metavar='O',
        dest="output_filenames",
        type=argdict_output_filenames.store_function(),
        default=argdict_output_filenames,
        help="output filename (--help-filename/-hf flag for an explanation about filenames)")

    output_group.add_argument('--print', '-P',
        dest="print_cube",
        action="store_true",
        default=False,
        help="print the result cube")

    output_group.add_argument('--stats', '-S',
        dest="print_stats",
        action="store_true",
        default=False,
        help="print statistics about the result cube")

    output_group.add_argument("--loop", "-l",
        metavar="D",
        dest="loop_dimensions",
        type=int,
        action="append",
        default=[],
        help="loop on dimension D (--help-loop/-hl for more information)")

    output_group.add_argument("--output-dtype", "-Ot",
        metavar="D",
        dest="output_dtypes",
        type=argdict_output_dtypes.store_function(),
        default=argdict_output_dtypes,
        help="output data type name (--help-data-types/-hd flag to show all available data types)")

    output_group.add_argument("--output-format", "-Of",
        dest="output_formats",
        type=argdict_output_formats.store_function(),
        default=argdict_output_formats,
        help="output file format")

    output_group.add_argument("--output-csv-separator", "-Os",
        metavar='S',
        dest="output_csv_separators",
        type=argdict_output_csv_separators.store_function(),
        default=argdict_output_csv_separators,
        help="separator to be used with '{0}' output file format".format(conf.FILE_FORMAT_CSV))

    output_group.add_argument("--output-text-delimiter", "-Od",
        metavar='D',
        dest="output_text_delimiters",
        type=argdict_output_text_delimiters.store_function(),
        default=argdict_output_text_delimiters,
        help="delimiter to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_group.add_argument("--output-text-newline", "-On",
        metavar='N',
        dest="output_text_newlines",
        type=argdict_output_text_newlines.store_function(),
        default=argdict_output_text_newlines,
        help="newline to be used with '{0}' output file format".format(conf.FILE_FORMAT_TEXT))

    output_group.add_argument("--output-text-converter", "-Oc",
        metavar='C',
        dest="output_text_converters",
        type=argdict_output_text_converters.store_function(),
        default=argdict_output_text_converters,
        help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(conf.FILE_FORMAT_TEXT))



    help_group = parser.add_argument_group("help options")
    help_group.add_argument("--help-dtypes", "-ht",
        dest="help_dtypes",
        action="store_true",
        default=False,
        help="show available dtypes")

    help_group.add_argument("--help-expression", "-he",
        dest="help_expression",
        action="store_true",
        default=False,
        help="show help about generic numpy expressions")

    help_group.add_argument("--help-extractor", "-hx",
        dest="help_extractor",
        action="store_true",
        default=False,
        help="show help about extractors")

    help_group.add_argument("--help-user-defined-variables", "-hV",
        dest="help_user_defined_variables",
        action="store_true",
        default=False,
        help="show help about user defined variables")

    help_group.add_argument("--help-numpy", "-hn",
        dest="help_numpy",
        action="store_true",
        default=False,
        help="show content of the numpy module")

    help_group.add_argument("--help-cubist-numpy", "-hc",
        dest="help_cubist_numpy",
        action="store_true",
        default=False,
        help="show content of the cubist_numpy module")

    help_group.add_argument("--help-filenames", "-hf",
        dest="help_filenames",
        action="store_true",
        default=False,
        help="show available keywords for filename interpolation")

    help_group.add_argument("--help-loop", "-hl",
        dest="help_loop",
        action="store_true",
        default=False,
        help="help about loop over dimension")

    try:
        args = parser.parse_args()
    except Exception as err:
        sys.stderr.write("error: {0}: {1}\n".format(err.__class__.__name__, err))
        sys.exit(1)

    if args.help_dtypes:
        log.PRINT("""\
Available dtypes
================
This is the list of the available numpy dtypes:
""")
        for dtype_name, dtype_description in conf.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=dtype_name, d=dtype_description))
        sys.exit(0)

    if args.help_cubist_numpy:
        from cubist import cubist_numpy as cubist_numpy
        help(cubist_numpy)
        sys.exit(0)

    if args.help_numpy:
        help(np)
        sys.exit(0)

    if args.help_expression:
        log.PRINT("""\
Generic numpy expressions
=========================
The --expression/-e options allows to pass a generic numpy expression to be
evaluated. The input cubes are available through the labels referring to them.

From the expression you can access:
* the numpy module, as 'numpy' or 'np';
* the cubist_numpy module, as 'cubist_numpy' or 'cnp';
* all the used defined variables.

The cubist_numpy module provides some numpy-based functions to operate with
cubes; see --help-cubist-numpy.
""")
        sys.exit(0)

    if args.help_extractor:
        log.PRINT("""\
Extractors
==========
An extractor can be associated to each input file to read only a portion of that
file. Due to memory opimization, only the portion is read, so there is no need
to temporarily store the entire file. This means that if you want to read only a
subcube from a huge file, you will use memory only for the subcube.

Extractors are lists of index selectors separated by 'x' or ','.

Each input file can have a specific extractor. The shape and the extractor must
have the same rank.

Each index selector can be:
* a python slice [start:]stop[:step], for instance
  - ':' -> select all indices
  - '1:' -> select all indices but the first
  - ':-3' -> select all indices but the last three
  - '::2' -> select from the first to the last indices with stride 2
* an integer number; in this case, only the corresponding index is selected on
  that dimension, and the dimension is skipped in the output.

For instance, if the shape is '8x1000x30':
* '-x :x0x:' will extract the subcube '8x30' corresponding to the plane with 0
  on the second dimension
* '-x 3:x8:10x:5' will extract a subcube '5x2x5' (remember that, in a python
  slice, the start is always included and the stop is always excluded.
""")
        sys.exit(0)

    if args.help_user_defined_variables:
        log.PRINT("""\
User defined variables
======================
User defined variables can be used in generic numpy expressions. For instance:
  -V alpha=1.5 -V beta=-0.5 -e 'alpha * i0 + beta * i1'
is equivalent to 
  -e '1.5 * i0 - 0.5 * i1'
Also input cubes and previusly defined variables can be used:
  -V a=10 -V b='a + 5' -V c='i0 * b'
will set
  * a = 10
  * b = 15
  * c = i0 * 15 ('i0' is the first cube)
""")
        sys.exit(0)

    if args.help_loop:
        log.PRINT("""\
Looping over dimensions
=======================
Suppose you have a _8x4x10_ cube, and you want to write _4_ _8x10_ cubes, one
for each index in the second dimension. The command is:

$ cubist -i a_{shape}.{format} -s 8x4x10 --loop 1 -o s_{shape}.{d1}.{format} -v
reading 320 'float32' elements (1280 bytes) from 'raw' file 'a_8x4x10.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.0.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.1.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.2.raw'...
writing 80 'float32' elements (320 bytes) to 'raw' file 's_8x10.3.raw'...
$

A loop over the four values for the second index is done when the output is
written; the 3-D cube is slices across the second dimension, and each plane
is saved to a different file.

The 'd1' key has been added to the available keys for the output filename
interpolation.

""")
        sys.exit(0)

    if args.help_filenames:
        log.PRINT("""\
Input filenames
===============
For each input filename, a label 'i<N>' is generated referring to the cube
read from this file; 'N' is the ordinal of the input filename.

For instance, 'i0' refers to the cube read from the first file, 'i1' to the cube
read from the second file, and so on.

These labels can be used to
* set specific parameters for each input file, like:
  - the format
  - the dtype
  - the shape
  - an extractor
  for instance, '-s i0=8x10' sets the shape for the first input cube only;
* refer to the corresponding cube in a generic numpy expression; in this case,
  'i0' refers to the cube read from the first input filename, after the
  extractor has been applied (indeed extractors are applied just during the
  file loading).

You can change the name of the label referring to a cube; simply put the
label before the filename, separated by '=': so, the option '-i a=a_8x10.raw'
will associate the read cube to the label 'a'; then, '-x a=:2x2:' sets an 
extractor for the file 'a_8x10.raw' only, and '-e "2.5 * a"' multiplies
the cube extracted from 'a_8x10.raw' by 2.5.

Output filenames
================
Also the output filenames have a label (by default 'o0'); the label can be used
to set specific parameters on the output file, for instance the format. It
cannot be used in the generic numpy expression.

For instance, '-o x=x_8x10.raw --output-dtype x=float64' applies the dtype
'float64' to the output file 'x_8x10.raw'.

Filename interpolation
======================
Filenames are interpolated; the following keywords are substituted:
* shape: the cube shape, for instance '3x2x4';
* rank: the cube shape rank, for instance '3' if the shape is '3x2x4';
* count: the number of elements, for instance '2x4';
* dtype: the data type, for instance 'float32';
* format: the file format ({ff})

For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
is '3x2x4' and file format is 'raw'.

This allows to specify the same filename as input and output, and still have
the output on separate files. For instance,
  -i a_{{shape}}.{{format}} -Oi -s 8x10 -If raw -Of text -Oc '%.4e'
will read 'a_8x10.raw' and write 'a_8x10.text'.

File formats
============
Three file formats are available:
* 'raw' is the default, for binary files; they are not portable across different
  platforms;
* 'text' is for text files; they have sub-options:
  - delimiter (usually a space) separating values in a row;
  - newline (usually '\\n') separating rows;
  - converter (for instance '%.18e') is the format specifier for values.
  for input files only the 'delimiter' can be set;
* 'csv' is for text files consisting of values separated by a separator; you can
  set
  - separator (by default ',') the separator between values.
""".format(ff='|'.join(conf.FILE_FORMATS)))
        sys.exit(0)

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
