#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import data_types
from cubist.clip import Clip
from cubist.shape import Shape
from cubist.cubist import Cubist
from cubist.errors import CubistError
from cubist.variable import VariableDefinition
from cubist.filename import InputFilename, OutputFilename
from cubist.selection import Selection

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def _create_cubist(logger, args):
    #logger.debug("# origins are  {0}".format(origins))
    #logger.debug("# shape is     {0}".format(shape))
    #logger.debug("# selection is {0}".format(selection))
    #logger.debug("# data_type is {0}".format(args.data_type))
    cubist = Cubist(
            data_type=args.data_type,
            logger=logger,
            input_csv_separator=getattr(args, 'input_csv_separator', None),
            output_csv_separator=getattr(args, 'output_csv_separator', None),
            input_text_delimiter=getattr(args, 'input_text_delimiter', None),
            output_text_delimiter=getattr(args, 'output_text_delimiter', None),
            input_text_newline=getattr(args, 'input_text_newline', None),
            output_text_newline=getattr(args, 'output_text_newline', None),
            input_text_converter=getattr(args, 'input_text_converter', None),
            output_text_converter=getattr(args, 'output_text_converter', None),
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None))
    return cubist

def _read_and_extract(cubist, logger, args, input_filename, selection):
    if args.shape is None:
        raise CubistError("--shape/-s is mandatory when input files are provided")
    cube = cubist.read(
            shape=args.shape,
            input_format=args.input_format,
            input_filename=input_filename,
            selection=selection)
    return cube

def _read(cubist, logger, args):
    selection = getattr(args, 'selection', None)
    expression = getattr(args, 'expression', None)
    if expression:
        for input_filename in args.input_filenames:
            _read_and_extract(cubist, logger, args, input_filename, selection)
        cube = cubist.evaluate_expression(expression=expression)
    else:
        if len(args.input_filenames) > 1:
            raise CubistError("too many input filenames")
        elif len(args.input_filenames) == 0:
            raise CubistError("no input filenames")
        input_filename = args.input_filenames[0]
        cube = _read_and_extract(cubist, logger, args, input_filename, selection)
    clip_arg = getattr(args, 'clip', None)
    if clip_arg is not None:
        cube = cubist.clip(cube=cube, clip=clip_arg)
    return cube

def main_print(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.print_cube(cube=cube)
    return 0

def main_stat(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.stat(cube=cube)
    return 0

def main_create(logger, args):
    cubist = _create_cubist(logger, args)
    cube = cubist.create(shape=args.shape, creation_mode=args.creation_mode)
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=args.output_filename)
    return 0
    
def main_write(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.in_place:
        if args.output_filename is None:
            if len(args.input_filenames) == 1:
                output_filename = OutputFilename(args.input_filenames[0])
            else:
                raise CubistError("--in-place/-Oi requires a single --input-filename option")
        else:
            raise CubistError("--in-place/-Oi is not compatible with --output-filename/-o")
    else:
        output_filename = args.output_filename
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    useless_run = True
    if args.print_cube:
        cubist.print_cube(cube=cube)
        useless_run = False
    if args.print_stats:
        cubist.stats(cube=cube)
        useless_run = False
    if output_filename is not None:
        useless_run = False
        cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=output_filename)
    if useless_run:
        logger.warning("warning: nothing to do; you should at least one of these options: --print/-P, --stats/-S, --output-filename/-o")
    return 0

def main():

    description = """\
Tool to read/write N-dimensional cubes

Read N-dimensional cubes, extract M-dimensional subcubes, evaluate generic numpy
expressions, and write the result.
"""
    epilog = ""
#(*) filenames are interpolated; the following keywords are substituted:
# + shape: the cube shape, for instance '3,2,4';
# + rank: the cube shape rank, for instance '3' if the shape is '3,2,4';
# + count: the number of elements, for instance '24';
# + data_type: the data type, for instance 'float32';
# + format: the file format ({ff})
# For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
# is '3x2x4' and file format is 'raw'.
#""".format(ff='|'.join(Cubist.FILE_FORMATS))

#(**) available data types are:
#    epilog += "\n".join(" + {0:16s} {1}".format(data_type_name, data_type_description) for data_type_name, data_type_description in data_types.DATA_TYPES.items())
    
    common_parser = argparse.ArgumentParser(
        add_help=False
    )

    common_parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    common_parser.add_argument("--trace-errors", "-t",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    parser = argparse.ArgumentParser(
        parents=[common_parser],
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.set_defaults(
        function=main_write,
    )
    
    parser.add_argument("--help-data-types", "-hd",
        dest="help_data_types",
        action="store_true",
        default=False,
        help="show available data types")

    parser.add_argument("--help-cubist-numpy", "-hc",
        dest="help_cubist_numpy",
        action="store_true",
        default=False,
        help="show content of the cubist_numpy module")

    parser.add_argument("--help-filename-interpolation", "-hi",
        dest="help_filename_interpolation",
        action="store_true",
        default=False,
        help="show available keywords for filename interpolation")

    parser.add_argument("--input-filename", "-i",
        metavar='I',
        dest="input_filenames",
        type=InputFilename,
        action="append",
        default=[],
        help="input filename (add --help-filename-interpolation/-hi flag for an explanation about filename interpolation)")

    input_formatting = parser.add_argument_group('input formatting')
    input_formatting.add_argument("--input-format", "-If",
        dest="input_format",
        choices=Cubist.FILE_FORMATS,
        default=Cubist.DEFAULT_FILE_FORMAT,
        help="input file format")

    input_formatting.add_argument("--input-csv-separator", "-Is",
        metavar='S',
        dest="input_csv_separator",
        default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
        help="separator to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_CSV))

    input_formatting.add_argument("--input-text-delimiter", "-Id",
        metavar='D',
        dest="input_text_delimiter",
        default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
        help="delimiter to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))

    input_formatting.add_argument("--input-text-newline", "-In",
        metavar='N',
        dest="input_text_newline",
        default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
        help="newline to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))

    input_formatting.add_argument("--input-text-converter", "-Ic",
        metavar='C',
        dest="input_text_converter",
        default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
        help="converter to be used with '{0}' input file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

    parser.add_argument("--accept-bigger-raw-files", "-a",
        action="store_true",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    write_output_filename_group = parser.add_mutually_exclusive_group()
    write_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    write_output_filename_group.add_argument("--output-filename", "-o",
        metavar='O',
        dest="output_filename",
        type=OutputFilename,
        required=False,
        help="output filename (add --help-filename-interpolation/-hi flag for an explanation about filename interpolation)")

    output_formatting = parser.add_argument_group("output formatting")
    output_formatting.add_argument("--output-format", "-Of",
        dest="output_format",
        choices=Cubist.FILE_FORMATS,
        default=Cubist.DEFAULT_FILE_FORMAT,
        help="output file format")

    output_formatting.add_argument("--output-csv-separator", "-Os",
        metavar='S',
        dest="output_csv_separator",
        default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
        help="separator to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_CSV))

    output_formatting.add_argument("--output-text-delimiter", "-Od",
        metavar='D',
        dest="output_text_delimiter",
        default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
        help="delimiter to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-newline", "-On",
        metavar='N',
        dest="output_text_newline",
        default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
        help="newline to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

    output_formatting.add_argument("--output-text-converter", "-Oc",
        metavar='C',
        dest="output_text_converter",
        default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
        help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

    parser.add_argument("--shape", "-s",
        metavar="[D0[:D1[...]]]",
        type=Shape,
        required=False,
        help="shape of the input filename")

    parser.add_argument("--data-type", "--dtype", "-d",
        metavar="D",
        dest="data_type",
        choices=data_types.DATA_TYPES.keys(),
        default=data_types.DEFAULT_DATA_TYPE,
        help="data type name (add --help-data-types/-hd flag to show all available data types)")

    parser.add_argument("--extract", "-x",
        metavar="X",
        dest="selection",
        type=Selection,
        required=False,
        help="subcube selection")

    parser.add_argument("--expression", "-e",
        metavar="E",
        dest="expression",
        type=str,
        required=False,
        help="expression to evaluate; you can use the 'numpy' module (also available as 'np') and the 'cubist_numpy' module (also available as 'cnp') (add --help-cubist-numpy/-hc flag to show the content of the 'cubist_numpy' module)")

    parser.add_argument("--clip", "-c",
        metavar="MIN[:MAX]",
        dest="clip",
        type=Clip,
        help="clipping")

    parser.add_argument("--add-var", "-V",
        metavar="N=V",
        action="append",
        type=VariableDefinition,
        default=[],
        help="add a variable definition")

    parser.add_argument('--print', '-P',
        dest="print_cube",
        action="store_true",
        default=False,
        help="print the result cube")

    parser.add_argument('--stats', '-S',
        dest="print_stats",
        action="store_true",
        default=False,
        help="print statistics about the result cube")

    args = parser.parse_args()

    if args.help_data_types:
        for data_type_name, data_type_description in data_types.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=data_type_name, d=data_type_description))
        sys.exit(0)

    if args.help_cubist_numpy:
        from cubist import cubist_numpy as cubist_numpy
        help(cubist_numpy)
        sys.exit(0)

    if args.help_filename_interpolation:
        log.PRINT("""\
Filenames are interpolated; the following keywords are substituted:
 + shape: the cube shape, for instance '3,2,4';
 + rank: the cube shape rank, for instance '3' if the shape is '3,2,4';
 + count: the number of elements, for instance '24';
 + data_type: the data type, for instance 'float32';
 + format: the file format ({ff})

For instance, 'a_{{shape}}.{{format}}' is converted to 'a_3x2x4.raw' if shape
is '3x2x4' and file format is 'raw'.
""".format(ff='|'.join(Cubist.FILE_FORMATS)))
        sys.exit(0)

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
