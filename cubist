#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import data_types
from cubist.clip import Clip
from cubist.shape import Shape
from cubist.cubist import Cubist
from cubist.errors import CubistError
from cubist.filename import InputFilename, OutputFilename
from cubist.selection import Selection

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def main_list(logger, args):
    if args.what == "data_types":
        for data_type_name, data_type_description in data_types.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=data_type_name, d=data_type_description))
    return 0

def _create_cubist(logger, args):
    #logger.debug("# origins are  {0}".format(origins))
    #logger.debug("# shape is     {0}".format(shape))
    #logger.debug("# selection is {0}".format(selection))
    #logger.debug("# data_type is {0}".format(args.data_type))
    cubist = Cubist(
            data_type=args.data_type,
            logger=logger,
            input_csv_separator=getattr(args, 'input_csv_separator', None),
            output_csv_separator=getattr(args, 'output_csv_separator', None),
            input_text_delimiter=getattr(args, 'input_text_delimiter', None),
            output_text_delimiter=getattr(args, 'output_text_delimiter', None),
            input_text_newline=getattr(args, 'input_text_newline', None),
            output_text_newline=getattr(args, 'output_text_newline', None),
            input_text_converter=getattr(args, 'input_text_converter', None),
            output_text_converter=getattr(args, 'output_text_converter', None),
            accept_bigger_raw_files=getattr(args, 'accept_bigger_raw_files', None))
    return cubist

def _read(cubist, logger, args):
    if not args.input_filenames:
        raise CubistError("no input filenames")
    selection_arg = getattr(args, 'selection', None)
    for input_filename in args.input_filenames:
        cube = cubist.read(
                shape=args.shape,
                input_format=args.input_format,
                input_filename=input_filename)
        if selection_arg is not None:
            cube = cubist.extract(cube=cube, selection=selection_arg)
    expression_arg = getattr(args, 'expression', None)
    if expression_arg is None:
        if len(args.input_filenames) > 1:
            raise CubistError("--expression/-e is mandatory when more than 1 input filename is provided")
    if expression_arg is not None:
        cube = cubist.evaluate_expression(expression=expression_arg)
    clip_arg = getattr(args, 'clip', None)
    if clip_arg is not None:
        cube = cubist.clip(cube=cube, clip=clip_arg)
    return cube

def main_print(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.print_cube(cube=cube)
    return 0

def main_stat(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    cubist.stat(cube=cube)
    return 0

def main_create(logger, args):
    cubist = _create_cubist(logger, args)
    cube = cubist.create(shape=args.shape, creation_mode=args.creation_mode)
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=args.output_filename)
    return 0
    
def main_extract(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read(cubist, logger, args)
    if args.output_filename is None:
        if len(args.input_filenames) == 1:
            output_filename = OutputFilename(args.input_filename)
        else:
            raise CubistError("--in-place/-Oi is not compatible with multiple input filenames")
    else:
        output_filename = args.output_filename
    #print "I", InputFilename.__filenames__
    #print "O", OutputFilename.__filenames__
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=output_filename)
    return 0

def main():
    description="""\
Tool to read/write N-dimensional cubes
"""
    epilog=""

    list_description = "List available data types"
    list_epilog = ""

    print_description = "Print N-dimensional cubes"
    stat_description = "Print statistics about N-dimensional cubes"

    create_description = "Create N-dimensional cubes"

    extract_description = """\
Extract M-dimensional subcubes from an N-dimensional cube (with M<=N)
"""
    filename_data_type_epilog = """\
(*) filenames are interpolated; the following keywords are substituted:
 + shape: the cube shape, for instance '3,2,4';
 + data_type: the data type, for instance 'float32';
 + count: the number of elements, for instance '24';
 + format: the file format
 For instance, 'a_{shape}.raw' is converted to 'a_3x2x4.raw'.

(**) available data types are:
"""
    filename_data_type_epilog += "\n".join(" + {0:16s} {1}".format(data_type_name, data_type_description) for data_type_name, data_type_description in data_types.DATA_TYPES.items())
    
    common_parser = argparse.ArgumentParser(
        add_help=False
    )

    common_parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    common_parser.add_argument("--trace-errors", "-t",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    top_level_parser = argparse.ArgumentParser(
        parents=[common_parser],
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = top_level_parser.add_subparsers()

    list_parser = subparsers.add_parser(
        "list",
        description=list_description,
        epilog=list_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    list_parser.set_defaults(
        function=main_list,
        what="data_types",
    )
    
    list_group = list_parser.add_mutually_exclusive_group()
    list_group.add_argument("--data-types", "-d",
        dest="what",
        action="store_const",
        const="data_types",
        help="list available data types")

    print_parser = subparsers.add_parser(
        "print",
        description=print_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    print_parser.set_defaults(
        function=main_print,
    )

    stat_parser = subparsers.add_parser(
        "stat",
        description=stat_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    stat_parser.set_defaults(
        function=main_stat,
    )

    create_parser = subparsers.add_parser(
        "create",
        description=create_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    create_parser.set_defaults(
        function=main_create,
    )

    create_parser.add_argument("--random-seed", "-r",
        metavar="R",
        dest="random_seed",
        type=str,
        default=None,
        help="random seed")
    
    create_parser.add_argument("--mode", "-m",
        metavar="M",
        dest="creation_mode",
        choices=Cubist.CREATION_MODES,
        default=Cubist.CREATION_MODE_RANGE,
        help="creation mode")

    extract_parser = subparsers.add_parser(
        "extract",
        description=extract_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    extract_parser.set_defaults(
        function=main_extract,
    )
    

    for parser in print_parser, stat_parser, extract_parser:
        parser.add_argument("--input-filename", "-i",
            metavar='I',
            dest="input_filenames",
            type=InputFilename,
            action="append",
            required=True,
            default=[],
            help="input filename (*)")

        input_formatting = parser.add_argument_group('input formatting')
        input_formatting.add_argument("--input-format", "-If",
            dest="input_format",
            choices=Cubist.FILE_FORMATS,
            default=Cubist.DEFAULT_FILE_FORMAT,
            help="input file format")

        input_formatting.add_argument("--input-csv-separator", "-Is",
            metavar='S',
            dest="input_csv_separator",
            default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
            help="separator to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_CSV))
    
        input_formatting.add_argument("--input-text-delimiter", "-Id",
            metavar='D',
            dest="input_text_delimiter",
            default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
            help="delimiter to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))
    
        input_formatting.add_argument("--input-text-newline", "-In",
            metavar='N',
            dest="input_text_newline",
            default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
            help="newline to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))
    
        input_formatting.add_argument("--input-text-converter", "-Ic",
            metavar='C',
            dest="input_text_converter",
            default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
            help="converter to be used with '{0}' input file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

        parser.add_argument("--accept-bigger-raw-files", "-a",
            action="store_true",
            default=False,
            help="if an input raw file is bigger than expected, simply issue a warning message")

    extract_output_filename_group = extract_parser.add_mutually_exclusive_group(required=True)
    extract_output_filename_group.add_argument("--in-place", "-Oi",
        action="store_true",
        help="output filename is input filename (notice that, due to interpolation, output file can be different from input file)")

    for parser, required in (create_parser, True), (extract_output_filename_group, False):
        parser.add_argument("--output-filename", "-o",
            metavar='O',
            dest="output_filename",
            type=OutputFilename,
            required=required,
            help="output filename (*)")

    for parser in create_parser, extract_parser:
        output_formatting = parser.add_argument_group("output formatting")
        output_formatting.add_argument("--output-format", "-Of",
            dest="output_format",
            choices=Cubist.FILE_FORMATS,
            default=Cubist.DEFAULT_FILE_FORMAT,
            help="output file format")

        output_formatting.add_argument("--output-csv-separator", "-Os",
            metavar='S',
            dest="output_csv_separator",
            default=Cubist.FILE_FORMAT_CSV_SEPARATOR,
            help="separator to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_CSV))

        output_formatting.add_argument("--output-text-delimiter", "-Od",
            metavar='D',
            dest="output_text_delimiter",
            default=Cubist.FILE_FORMAT_TEXT_DELIMITER,
            help="delimiter to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

        output_formatting.add_argument("--output-text-newline", "-On",
            metavar='N',
            dest="output_text_newline",
            default=Cubist.FILE_FORMAT_TEXT_NEWLINE,
            help="newline to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

        output_formatting.add_argument("--output-text-converter", "-Oc",
            metavar='C',
            dest="output_text_converter",
            default=Cubist.FILE_FORMAT_TEXT_CONVERTER,
            help="converter to be used with '{0}' output file format (e.g. '%%.18e')".format(Cubist.FILE_FORMAT_TEXT))

    for parser in extract_parser, create_parser, print_parser, stat_parser:
        parser.add_argument("--shape", "-s",
            metavar="[D0[:D1[...]]]",
            type=Shape,
            required=True,
            help="shape of the input filename")

        parser.add_argument("--data-type", "--dtype", "-d",
            metavar="D",
            dest="data_type",
            choices=data_types.DATA_TYPES.keys(),
            default=data_types.DEFAULT_DATA_TYPE,
            help="data type name (**)")

    for parser in extract_parser, print_parser, stat_parser:
        parser.add_argument("--extract", "-x",
            metavar="X",
            dest="selection",
            type=Selection,
            required=False,
            help="subcube selection")

        parser.add_argument("--expression", "-e",
            metavar="E",
            dest="expression",
            type=str,
            required=False,
            help="expression to evaluate")

        parser.add_argument("--clip", "-c",
            metavar="MIN[:MAX]",
            dest="clip",
            type=Clip,
            help="clipping")

    args = top_level_parser.parse_args()

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
