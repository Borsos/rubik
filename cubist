#!/usr/bin/env python3

import sys
import argparse

import random

import numpy as np

from cubist.application import log
from cubist import data_types
from cubist.cubist import Cubist
from cubist.shape import Shape
from cubist.selection import Selection

if sys.version_info.major == 2:
    PY3 = False
else:
    PY3 = True

def main_list(logger, args):
    if args.what == "data_types":
        for data_type_name, data_type_description in data_types.DATA_TYPES.items():
            log.PRINT("{n:16s} {d}".format(n=data_type_name, d=data_type_description))
    return 0

def _create_cubist(logger, args):
    #logger.debug("# origins are  {0}".format(origins))
    #logger.debug("# shape is     {0}".format(shape))
    #logger.debug("# selection is {0}".format(selection))
    #logger.debug("# data_type is {0}".format(args.data_type))
    cubist = Cubist(
            data_type=args.data_type,
            logger=logger,
            input_text_separator=args.input_text_separator,
            output_text_separator=args.output_text_separator,
            accept_bigger_raw_files=args.accept_bigger_raw_files)
    return cubist

def _read_and_extract(cubist, logger, args):
    cube = cubist.read(
            shape=args.shape,
            input_format=args.input_format,
            input_filename=args.input_filename)
    selection_arg = getattr(args, 'selection', None)
    if selection_arg is not None:
        return cubist.extract(cube=cube, selection=args.selection)
    else:
        return cube

def main_print(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read_and_extract(cubist, logger, args)
    cubist.print_cube(cube=cube)
    return 0

def main_stat(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read_and_extract(cubist, logger, args)
    cubist.stat(cube=cube)
    return 0

def main_create(logger, args):
    cubist = _create_cubist(logger, args)
    cube = cubist.create(shape=args.shape, creation_mode=args.creation_mode)
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=args.output_filename)
    return 0
    
def main_extract(logger, args):
    cubist = _create_cubist(logger, args)
    cube = _read_and_extract(cubist, logger, args)
    cubist.write(
            cube=cube,
            output_format=args.output_format,
            output_filename=args.output_filename)
    return 0

def main():
    description="""\
Tool to read/write N-dimensional cubes
"""
    epilog=""

    list_description = "List available data types"
    list_epilog = ""

    print_description = "Print N-dimensional cubes"
    stat_description = "Print statistics about N-dimensional cubes"

    create_description = "Create N-dimensional cubes"

    extract_description = """\
Extract M-dimensional subcubes from an N-dimensional cube (with M<=N)
"""
    filename_data_type_epilog = """\
(*) filenames are interpolated; the following keywords are substituted:
 + shape: the cube shape, for instance '3,2,4';
 + data_type: the data type, for instance 'float32';
 + count: the number of elements, for instance '24';
 + bytes: the number of elements, for instance '96'.
 For instance, 'a_{xshape}.raw' is converted to 'a_3x2x4.raw'.

(**) available data types are:
"""
    filename_data_type_epilog += "\n".join(" + {0:16s} {1}".format(data_type_name, data_type_description) for data_type_name, data_type_description in data_types.DATA_TYPES.items())
    
    common_parser = argparse.ArgumentParser(
        add_help=False
    )

    common_parser.add_argument("--verbose", "-v",
        dest="verbose_level",
        action="count",
        default=0,
        help="set verbose level")

    common_parser.add_argument("--trace-errors", "-t",
        dest="trace_errors",
        action="store_true",
        default=False,
        help="show error traceback")

    common_parser.add_argument("--input-text-separator", "-is",
        dest="input_text_separator",
        default=Cubist.FILE_FORMAT_TEXT_SEPARATOR,
        help="separator to be used with '{0}' input file format".format(Cubist.FILE_FORMAT_TEXT))

    common_parser.add_argument("--output-text-separator", "-os",
        dest="output_text_separator",
        default=Cubist.FILE_FORMAT_TEXT_SEPARATOR,
        help="separator to be used with '{0}' output file format".format(Cubist.FILE_FORMAT_TEXT))

    common_parser.add_argument("--accept-bigger-raw-files", "-a",
        action="store_true",
        default=False,
        help="if an input raw file is bigger than expected, simply issue a warning message")

    top_level_parser = argparse.ArgumentParser(
        parents=[common_parser],
        description=description,
        epilog=epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = top_level_parser.add_subparsers()

    list_parser = subparsers.add_parser(
        "list",
        description=list_description,
        epilog=list_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    list_parser.set_defaults(
        function=main_list,
        what="data_types",
    )
    
    list_group = list_parser.add_mutually_exclusive_group()
    list_group.add_argument("--data-types", "-d",
        dest="what",
        action="store_const",
        const="data_types",
        help="list available data types")

    print_parser = subparsers.add_parser(
        "print",
        description=print_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    print_parser.set_defaults(
        function=main_print,
    )

    stat_parser = subparsers.add_parser(
        "stat",
        description=stat_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    stat_parser.set_defaults(
        function=main_stat,
    )

    create_parser = subparsers.add_parser(
        "create",
        description=create_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    create_parser.set_defaults(
        function=main_create,
    )

    create_parser.add_argument("--random-seed", "-r",
        metavar="R",
        dest="random_seed",
        type=str,
        default=None,
        help="random seed")
    
    create_parser.add_argument("--mode", "-m",
        metavar="M",
        dest="creation_mode",
        choices=Cubist.CREATION_MODES,
        default=Cubist.CREATION_MODE_RANGE,
        help="creation mode")

    extract_parser = subparsers.add_parser(
        "extract",
        description=extract_description,
        epilog=filename_data_type_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        parents=[common_parser],
    )

    extract_parser.set_defaults(
        function=main_extract,
    )
    

    for parser in print_parser, stat_parser, extract_parser:
        parser.add_argument("--input-filename", "-i",
            dest="input_filename",
            required=True,
            help="input filename (*)")

        parser.add_argument("--input-format", "-if",
            dest="input_format",
            choices=Cubist.FILE_FORMATS,
            default=Cubist.DEFAULT_FILE_FORMAT,
            help="input file format")

    for parser in create_parser, extract_parser:
        parser.add_argument("--output-filename", "-o",
            dest="output_filename",
            required=True,
            help="output filename (*)")

        parser.add_argument("--output-format", "-of",
            dest="output_format",
            choices=Cubist.FILE_FORMATS,
            default=Cubist.DEFAULT_FILE_FORMAT,
            help="output file format")

    for parser in extract_parser, create_parser, print_parser, stat_parser:
        parser.add_argument("--shape", "-s",
            metavar="[D0[:D1[...]]]",
            type=Shape,
            required=True,
            help="shape of the input filename")

        parser.add_argument("--data-type", "--dtype", "-d",
            metavar="D",
            dest="data_type",
            choices=data_types.DATA_TYPES.keys(),
            default=data_types.DEFAULT_DATA_TYPE,
            help="data type name (**)")

    for parser, required in (extract_parser, True), (print_parser, False), (stat_parser, False):
        parser.add_argument("--extract", "-x",
            metavar="S",
            dest="selection",
            type=Selection,
            required=required,
            help="subcube selection")

    args = top_level_parser.parse_args()

    logger = log.set_logger(args.verbose_level)
    
    return_code = 0
    try:
        return_code = args.function(logger, args)
    except:
        log.trace_error(args.trace_errors)

    if return_code:
        sys.exit(return_code)


if __name__ == "__main__":
    main()
